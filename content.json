{"meta":{"title":"我的博客","subtitle":"zyyy","description":"今天跑步了吗","author":"zyyy","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-10-07T16:00:00.000Z","updated":"2022-10-08T14:05:40.344Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2022-10-08T14:07:24.396Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-08T14:03:47.000Z","updated":"2022-10-08T14:05:47.261Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue小总结","slug":"Vue小总结","date":"2022-11-12T05:57:17.000Z","updated":"2022-11-13T13:11:35.280Z","comments":true,"path":"2022/11/12/Vue小总结/","link":"","permalink":"http://example.com/2022/11/12/Vue%E5%B0%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"初学Vue小总结(记录 以便复习) 第一部分 (vue基础_基本指令)vue是什么？ Vue.js是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。 为什么要学习vue? 随着项目业务场景的复杂,传统模式（html+jquery）已无法满足需求就出现了Angular&#x2F;React&#x2F;Vue等框架 主流框架之一(React Angular Vue)： React和Vue玩的最好的一手就是”数据的双向绑定” 易用、灵活、高效： 与jQuery请求拼字符串相比，Vue直接一个json串搞定 库和框架的区别 库(如jQuery) 库是一系列函数的集合. 提供大量API，体现了封装的思想、我们想要实现某个功能，需要自己调用这些API的方法（.css()、.style().color） 特点：开发人员说了算。 框架 框架提供了一套完整解决方案,它指定了一套规则，我们要使用这个框架，就要按照他们的规则去编写代码，编写好了之后，框架会在适当的时机去解析我们的代码 特点：框架说了算。 区别：控制反转(谁说了算，谁起主导作用) MVVM Vue 使用的是 MVVM 模式为什么要学习 MVVM ? MVVM &#x3D;&#x3D;&#x3D;&gt; M &#x2F; V &#x2F; VM M : model 数据层 V : view 视图层 VM : ViewModel 视图模型 核心 : V&lt;&#x3D;&#x3D;&#x3D;&gt; VM &lt;&#x3D;&#x3D;&#x3D;&gt; M 说明： 将从M层获取的msg：123填充到V层，大牛3行代码，小牛30行，小白300行，性能肯定是不一样的 而现在，不管大牛小牛小白，学了Vue之后，利用MVVM它来帮你做，达到性能统一 M：数据层，还是Model V：视图层，还是View VM（原来的C层）:ViewModel层 视图数据层（vm）,其实就是Vue的实例（官网中Vue vm &#x3D; new Vue()） 数据的双向绑定：单向更改，双向绑定 略…. Vue入门 vue的基本使用引入vue.js后: 参数详解 el el作用:指定当前Vue实例所管理的视图,值通常是id选择器 el的值可以是css选择器,通常是id选择器 el的值不能是html标签和body标签 data data作用:指定当前Vue实例的数据对象 data中的数据是响应式数据 值是一个对象 {属性: 值} 所有数据部分写在data中 在当前Vue实例所管理的视图中通过属性名使用data中的数据 可以通过vm.$data.属性 访问数据 可以通过vm.属性 访问数据(更简单) methods methods作用:指定当前Vue实例中的方法 可以直接通过vm实例访问这些方法， 方法中的 this 自动绑定为 Vue 实例 插值表达式 解释：使用&#123;&#123;&#125;&#125;（插值表达式）从data中获取数据，并展示在模板中 说明：&#123;&#123;&#125;&#125;中只能出现JavaScript表达式 说明：数据对象的属性值发生了改变，插值处的内容都会更新 表达式 - 运算符 : {{ msg + 500}} - 调用方法 : {{ [14,7].join('-') }} - 三元 : {{ true ? '真':''假 }} 不能使用语句 if语句 for语句 代码块演示 vue常用指令 v-text和v-html v-text:更新标签中的内容 v-text和插值表达式的区别 v-text 更新整个标签中的内容 插值表达式: 更新标签中局部的内容 v-html:更新标签中的内容&#x2F;标签 可以渲染内容中的HTML标签 注意:尽量避免使用，容易造成危险 (XSS跨站脚本攻击) 代码演示 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 设置vue所管理的视图 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 获取Vue对象中data里的数据 --&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;,我是p标签中的内容&lt;/p&gt; &lt;p v-text=&quot;text&quot;&gt;我是p标签中的内容&lt;/p&gt; &lt;p v-text=&quot;html&quot;&gt;我是p标签中的内容&lt;/p&gt; &lt;p v-html=&quot;text&quot;&gt;我是p标签中的内容&lt;/p&gt; &lt;p v-html=&quot;html&quot;&gt;我是p标签中的内容&lt;/p&gt; &lt;/div&gt; &lt;!-- 引入Vue.js文件 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 创建Vue对象 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; const vm = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; text:&#x27;点我试试看&#x27;, html:&#x27;&lt;a href=&quot;http://www.itcast.cn&quot;&gt;试试就试试&lt;/a&gt;&#x27; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-if和v-show作用:根据表达式的bool值进行判断是否渲染该元素 代码演示 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 设置vue所管理的视图 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 获取vue对象中data里的数据 --&gt; &lt;p v-if=&quot;isShow&quot;&gt;我是v-if数据&lt;/p&gt; &lt;p v-show=&quot;isShow&quot;&gt;我是v-show数据&lt;/p&gt; &lt;/div&gt; &lt;!-- 引入Vue.js --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 创建Vue对象 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; isShow:false &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注：v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 因此，如果需要非常频繁地切换，则使用 v-show 较好； 如果在运行时条件很少改变，则使用 v-if 较好。 v-on 作用:使用 v-on 指令绑定 DOM 事件，并在事件被触发时执行一些 JavaScript 代码。 语法: v-on:事件名.修饰符 = &quot;methods中的方法名&quot; ; v-on的简写方法: @事件名.修饰符 = &quot;methods中的方法名&quot; 修饰符 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;location.href=&#x27;http://www.baidu.com&#x27;&quot;&gt;百度&lt;/button&gt; &lt;button onclick=&quot;method1()&quot;&gt;百度&lt;/button&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--需求: 点击按钮 修改 点击次数--&gt; &lt;!--在事件内 直接书写js代码--&gt; &lt;!--1 原始方式--&gt; &lt;button v-on:click=&quot;count++&quot;&gt;按钮1&lt;/button&gt; &lt;!--2 简化方式--&gt; &lt;button @click=&quot;count++&quot;&gt;按钮2&lt;/button&gt; &lt;!--3 给事件绑定方法--&gt; &lt;button @click=&quot;fn1()&quot;&gt;按钮3&lt;/button&gt; &lt;!--4 给事件绑定方法, 还要给方法传递参数--&gt; &lt;button @click=&quot;fn2(count)&quot;&gt;按钮4&lt;/button&gt; &lt;!--5 限制点击事件只会被执行一次--&gt; &lt;button @click=&quot;fn3()&quot;&gt;按钮5&lt;/button&gt; &lt;button @click=&quot;fn3&quot;&gt;按钮52222222&lt;/button&gt; &lt;button @click.once=&quot;fn3()&quot;&gt;按钮6&lt;/button&gt; &lt;p&gt;上面的按钮被点击的次数: &#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el : &quot;#app&quot;, data : &#123; count : 0 &#125;, methods : &#123; fn1 : function() &#123; console.info(&quot;方法一 被调用了... ...&quot;) this.count++; &#125;, fn2 : function(cou) &#123; console.info(&quot;按钮被点击的次数: &quot; + cou); &#125;, fn3 : function () &#123; console.info(&quot;方法三 被调用了... ...&quot;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-forv-for作用: 列表渲染,当遇到相似的标签结构时,就用v-for去渲染 格式 (item,index) in 数组 参数item:数组中的每个元素 参数index:数组中元素的下标 (value, key, index) in 对象 参数index:对象中每对key-value的索引 从0开始 参数key:键 参数value:值 代码演示 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;!--获取vue中data里面的数据--&gt; &lt;!--遍历数组--&gt; &lt;p v-for=&quot;(item, index) in arr&quot;&gt;&#123;&#123;index+1&#125;&#125; ===== &#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;hr/&gt; &lt;!--遍历对象--&gt; &lt;p v-for=&quot;(value, key, index) in person&quot;&gt;&#123;&#123;index+1&#125;&#125; ==== &#123;&#123;key&#125;&#125; ==== &#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;hr/&gt; &lt;!--遍历对象数组--&gt; &lt;p v-for=&quot;(person, index) in personArr&quot;&gt;&#123;&#123;index+1&#125;&#125; ===== &#123;&#123;person.name&#125;&#125; ==== &#123;&#123;person.age&#125;&#125; ===== &#123;&#123;person.gender&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el : &quot;#app&quot;, data : &#123; arr : [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;], person : &#123;name:&quot;刘备&quot;, age:&quot;25&quot;, gender:&quot;男&quot;&#125;, personArr : [ &#123;name:&quot;刘备&quot;, age:&quot;25&quot;, gender:&quot;男&quot;&#125;, &#123;name:&quot;关羽&quot;, age:&quot;28&quot;, gender:&quot;男&quot;&#125;, &#123;name:&quot;张飞&quot;, age:&quot;29&quot;, gender:&quot;男&quot;&#125;, ] &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-bind作用: 可以绑定标签上的任何属性。格式: v-bind:属性&#x3D;”值” 简写格式 :属性&#x3D;”值” 属性值一部分进行替换的格式 :属性&#x3D;”‘常亮值’ + vue对象data中的数据” 代码演示 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;v-bind&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;font size=&quot;5&quot; v-bind:color=&quot;ys1&quot;&gt;传智播客&lt;/font&gt; &lt;font size=&quot;5&quot; :color=&quot;ys2&quot;&gt;黑马程序员&lt;/font&gt; &lt;hr&gt; &lt;a href=&quot;http://www.itcast.cn&quot;&gt;itcast&lt;/a&gt;&lt;br/&gt; &lt;a :href=&quot;&#x27;http://&#x27; + url&quot;&gt;京东&lt;/a&gt;&lt;br/&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; ys1:&quot;red&quot;, ys2:&quot;yellow&quot;, url:&quot;www.jd.cn&quot; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-model作用: 表单元素的绑定 特点: 双向数据绑定 vue对象中的数据发生变化可以更新到界面 通过界面可以更改vue对象中数据 v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。应该在 data选项中声明初始值。 格式: ​ 在表单控件或者组件上创建双向绑定。细节请看下面的代码演示。 代码演示 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;v-model&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; 姓名:&lt;input type=&quot;text&quot; id=&quot;username&quot; v-model=&quot;user.username&quot;&gt;&lt;br&gt; 密码:&lt;input type=&quot;password&quot; id=&quot;password&quot; v-model=&quot;user.password&quot;&gt;&lt;br&gt; &lt;input type=&quot;button&quot; @click=&quot;fun&quot; value=&quot;获取&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot;fun2()&quot; value=&quot;修改&quot;&gt;&lt;/div&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, //表示当前vue对象接管了div区域 data:&#123; //设置初始值 user:&#123;username:&quot;zhangsan&quot;,password:&quot;123&quot;&#125; , &#125;, methods:&#123; fun:function()&#123; //获取界面输入后,更新的值 console.info(this.user.username); console.info(this.user.password); &#125;, fun2:function() &#123; //对数据的值 再次赋值进行更新 this.user.username = &quot;武松&quot;; this.user.password = &quot;555555555&quot;; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第二部分 (生命周期)vue的生命周期 Vue生命周期生命周期是指Vue实例或者组件从诞生到消亡经历的每一个阶段，在这些阶段的前后可以设置一些函数当做事件来调用。 生命周期钩子函数的定义：从Vue被创建，到挂到页面上运行，再到页面关闭Vue被销毁，这三个阶段总是伴随着组件各种的事情，这些事情统称为Vue的生命周期函数，简称：钩子函数 开发人员可以通过Vue提供的钩子函数，让我们写的代码参与到Vue的生命周期里面来，让我们的代码在合适的阶段起到相对应的作用 注意 1：vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可 2：钩子函数的名称都是vue中规定好的 vue生命周期可以分为八个阶段，分别是： beforeCreate（创建前）、created（创建后）、beforeMount(载入前)、mounted（载入后）、beforeUpdate（更新前）、updated（更新后）、beforeDestroy（销毁前）、destroyed（销毁后） 我们如果想在页面加载完毕后就要执行一些操作的话，可以使用created和mounted钩子函数，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;生命周期&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Vue的生命周期&#x27; &#125;, beforeCreate: function() &#123; console.group(&#x27;------beforeCreate创建前状态------&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data : &quot; + this.$data); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message);//undefined &#125;, created: function() &#123; console.group(&#x27;------created创建完毕状态------&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el : &quot; + this.$el); //undefined console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message); //已被初始化 &#125;, beforeMount: function() &#123; console.group(&#x27;------beforeMount挂载前状态------&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el : &quot; + (this.$el)); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message); //已被初始化 &#125;, mounted: function() &#123; console.group(&#x27;------mounted 挂载结束状态------&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el : &quot; + this.$el); //已被初始化 console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data : &quot; + this.$data); //已被初始化 console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message); //已被初始化 &#125;, beforeUpdate: function() &#123; console.group(&#x27;beforeUpdate 更新前状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message); &#125;, updated: function() &#123; console.group(&#x27;updated 更新完成状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message); &#125;, beforeDestroy: function() &#123; console.group(&#x27;beforeDestroy 销毁前状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message); &#125;, destroyed: function() &#123; console.group(&#x27;destroyed 销毁完成状态===============》&#x27;); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el : &quot; + this.$el); console.log(this.$el); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data : &quot; + this.$data); console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message) &#125; &#125;) // 设置data中message数据值 //vm.message = &quot;good...&quot;; // 销毁Vue对象 //vm.$destroy(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Vue的Ajax异步请求 axios在Vue.js中发送网络请求本质还是ajax，我们可以使用插件方便操作。 vue-resource: Vue.js的插件，已经不维护，不推荐使用 axios :不是vue的插件，可以在任何地方使用，推荐 说明: 既可以在浏览器端又可以在node.js中使用的发送http请求的库，支持Promise，不支持jsonp 如果遇到jsonp请求, 可以使用插件 jsonp 实现 通过Http请求的不同类型(POST&#x2F;DELETE&#x2F;PUT&#x2F;GET)来判断是什么业务操作(CRUD ) 5.1 HTTP方法规则举例 HTTP方法 数据处理 说明 POST Create 新增一个没有id的资源 GET Read 取得一个资源 PUT Update 更新一个资源。或新增一个含 id 资源(如果 id 不存在) DELETE Delete 删除一个资源 5.2 发送get请求1234567axios.get(&#x27;/user?id=12345&#x27;) .then(response =&gt; &#123; console.log(response.data); &#125;) .catch(error =&gt; &#123; console.dir(error) &#125;); 5.3 发送post请求1234567axios.post(&#x27;/user&#x27;, &quot;name=迪丽热巴&amp;age=23&quot;) .then(response =&gt; &#123; console.log(response.data); &#125;) .catch(error =&gt; &#123; console.dir(err) &#125;); axios.post(请求路径, 携带参数) ​ .then(response&#x3D;&gt;{ ​ xxx ​ }) ​ .catch(error &#x3D;&gt; { ​ yyyy ​ }); 为方便起见，为所有支持的请求方法提供了别名 axios.request(confifig) axios.get(url[, confifig]) axios.delete(url[, confifig]) axios.head(url[, confifig]) axios.post(url[, data[, confifig]]) axios.put(url[, data[, confifig]]) axios.patch(url[, data[, confifig]]) Springmvc.xml头信息 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;/beans&gt; 第三部分 (组件)1.组件概念 组件可以看作是一些可复用的ui模块 小到一个标签 : &lt;div&gt;哈哈&lt;/div&gt; 大到一个页面 :&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 一个组件对应 一个Vue实例 组件 &#x3D;&#x3D;&#x3D; Vue实例 &#x3D;&#x3D; new Vue ( options ) 官网 : 组件是可复用的 Vue 实例 2.组件化开发 概念 :将一个完整的页面,抽离成一个个独立的组件,最终,通过这一个个独立组件完成整个的页面(项目)的功能 组件化开发的优势&#x2F;作用 : 复用 3.组件的基本使用 先注册, 再使用 Vue 中的两种注册组件的方法 1.全局注册 2.局部注册 12全局组件在所有的vue实例中都可以使用局部组件在所有的当前实例中可以使用 注册全局组件 - 基本使用 12345678910/** * 第一个参数 : 组件名 * 第二个参数 : 是一个配置对象, 该配置对象与 Vue 实例的配置对象几乎完全相同 * 也就是说: vue实例中用到的配置项,和组件中的配置项几乎相同 */Vue.component(&#x27;child&#x27;, &#123; template: ` &lt;h1 class=&quot;red&quot;&gt;这是child组件&lt;/h1&gt; `&#125;) 注意点 注册全局组件也是放到 vm 实例之前 模板只能有一个根节点 组件的配置项和 vue 实例 的配置项一样 (如：data、methods、filters、watch、computed、钩子函数等) 组件的 data 是一个函数 , 并且返回一个对象 1234567891011121314151617// 演示为什么vue在组件中的数据采用函数,而不是对象// 原因 : 只想让组件复用,不想让数据复用var Component = function() &#123;&#125;// 使用对象Component.prototype.data = &#123; demo: 123&#125;// 使用函数Component.prototype.data = function() &#123; return &#123; demo: 111 &#125;&#125;var component1 = new Component()var component2 = new Component()component1.data().demo = &#x27;8888&#x27;console.log(component2.data().demo) // 456 使用组件 当标签一样使用 &lt;child&gt;&lt;/child&gt; 4.注册局部组件 局部组件只能在当前vue实例中使用 示例 : 1234567891011// 注册局部组件：components: &#123; // child表示组件名称 // 值为配置对象，与 Vue.component 中的第二个参数相同 // 注意：子组件child属于 Vue实例，因此，只能在 Vue实例的模板中使用 child: &#123; template: ` &lt;div&gt;这是局部组件 child&lt;/div&gt; ` &#125;&#125; 获取组件（获取DOM元素） - refs 说明 : vm.$refs 一个对象, 持有已注册过 ref 的所有子组件 ( HTML 元素) 使用 : 注册 12345// $refs = &#123; div : div元素, child:child组件 &#125;// 标签&lt;div ref=&quot;div&quot;&gt;哈哈&lt;/div&gt;// 组件 &lt;child ref=&quot;child&quot;&gt;&lt;/child&gt; 注意 : mounted 中使用 1234// mounted 操作DOM* this.$refs.div* this.$refs.child 注意点 : 如果获取的是一个子组件,那么通过 ref 就能获取到子组件中的 data 和 methods 12this.$refs.child.numthis.$refs.child.fn 场景 : 一般在第三方的组件中, 可能会用到这个功能 示例 : 12345678// 组件 &lt;div ref=&quot;div&quot;&gt;哈哈&lt;/div&gt; &lt;child ref=&quot;child&quot;&gt;&lt;/child&gt;// js mounted() &#123; console.log(this.$refs.div) console.log(this.$refs.child.fn) &#125; 第四部分 (路由)1.单页面应用程序 SPA : Single Page Application 单页面应用程序 MPA : Multiple Page Application 多页面应用程序 单页 web 应用 就是只有一个 web 页面的应用,是加载单个 HTML 页面,并在用户与应用程序交互时, 动态更新该页面的 web 应用程序 区别 对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面 对于单页应用程序来说, 只有第一次会加载页面,以后的每次请求,仅仅是获取必要的数据.然后,由页面中 js 解析获取的数据,展示在页面中 单页面优势 : 减少了请求体积，加快页面响应速度，降低了对服务器的压力 更好的用户体验，让用户在 web app 感受 native app 的流畅, (局部刷新) 单页面劣势 : 开发成本高 (需要学习路由) 不利于 SEO 演示 : https://music.163.com/ 2.路由介绍 路由 : 是浏览器 URL 中的哈希值( # hash) 与 展示视图内容 之间的对应规则 简单来说,路由就是一套映射规则(一对一的对应规则), 由开发人员制定规则 当 URL 中的哈希值( # hash) 发生改变后,路由会根据制定好的规则, 展示对应的视图内容 为什么要学习路由? 在 web App 中, 经常会出现通过一个页面来展示和管理整个应用的功能. SPA 往往是功能复杂的应用,为了有效管理所有视图内容,前端路由 应运而生. vue 中的路由 : 是 hash 和 component 的对应关系, 一个哈希值对应一个组件 3.路由的基本使用准备工作 (3个) 安装 : npm i vue-router 引入 : 123&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;// 千万注意 :引入路由一定要在引入vue之后,因为vue-router是基于vue工作的&lt;script src=&quot;./node_modules/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; 实例路由对象 + 挂载到vue上 实例路由对象 : const router = new VueRouter() 挂载到vue上 : new Vue(&#123; router,data,methods &#125;) 验证路由是否挂载成功, 就看打开页面,最后面有没有个 #/ 具体步骤 (4个) 1.入口 2.路由规则 3.组件 6.出口 12345678910111213141516171819202122# 1. 入口 // 方式1 : url地址为入口 调试开发用 输入url地址 改变哈希值 `01-路由的基本使用.html#/one` // 方式2 : 声明式导航 : router-link+to (见下面介绍)# 2. 路由规则// path : 路由路径// component : 将来要展示的路由组件routes: [ &#123; path: &#x27;/one&#x27;, component: One &#125;, &#123; path: &#x27;/two&#x27;, component: Two &#125;]# 3. 组件// 使用返回值的这个组件名称const One = Vue.component(&#x27;one&#x27;, &#123; template: ` &lt;div&gt; 子组件 one &lt;/div&gt; `&#125;)# 6. 出口&lt;!-- 出口 组件要展示的地方--&gt;&lt;router-view&gt;&lt;/router-view&gt;# 总结拿到入口哈希路径, 根据路由匹配规则,找到对应的组件,显示到对应的出口位置 4.路由使用注意事项 入口 最常用的入口 是 声明式导航 router-link 12345&lt;!-- router-link 组件最终渲染为 a标签, to属性转化为 a标签的href属性to 属性的值 , 实际上就是哈希值,将来要参与路由规则中进行与组件匹配 --&gt;&lt;router-link to=&quot;/one&quot;&gt;首页&lt;/router-link&gt; 组件 123const One = &#123; template: `&lt;div&gt; 子组件 one &lt;/div&gt; `&#125; 演示 : 多个组件匹配 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;app&quot;&gt; &lt;!-- 1 路由入口：链接导航 --&gt; &lt;router-link to=&quot;/one&quot;&gt;One&lt;/router-link&gt; &lt;router-link to=&quot;/two&quot;&gt;Two&lt;/router-link&gt; &lt;!-- 4 路由出口：用来展示匹配路由视图内容 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;!-- 导入 vue.js --&gt;&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 导入 路由文件 --&gt;&lt;script src=&quot;./node_modules/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 3 创建两个组件 const One =&#123; template: &#x27;&lt;h1&gt;这是 one 组件&lt;/h1&gt;&#x27; &#125; const Two = &#123; template: &#x27;&lt;h1&gt;这是 two 组件&lt;/h1&gt;&#x27; &#125; // 0 创建路由对象 const router = new VueRouter(&#123; // 2. 路由规则 routes: [ &#123; path: &#x27;/one&#x27;, component: One &#125;, &#123; path: &#x27;/two&#x27;, component: Two &#125; ] &#125;) const vm = new Vue(&#123; el: &#x27;#app&#x27;, //0. 不要忘记，将路由与vue实例关联到一起！ router &#125;)&lt;/script&gt; 5.入口导航菜单高亮处理 点击导航 &#x3D;&gt; 元素里添加了两个类 12&lt;a href=&quot;#/one&quot; class=&quot;router-link-exact-active router-link-active&quot;&gt;One&lt;/a&gt;&lt;a href=&quot;#/two&quot; class=&quot;&quot;&gt;Two&lt;/a&gt; 修改方式1 : 直接修改类的样式 12345.router-link-exact-active,.router-link-active &#123; color: red; font-size: 50px;&#125; 修改方式2 : 使用存在过的类样式 &#x3D;&gt; 修改默认高亮类名 123456const router = new VueRouter(&#123; routes: [], // 修改默认高亮的a标签的类名 // red 是已经存在过的 linkActiveClass: &#x27;red&#x27;&#125;) 6.路由配置6.1 动态路由 &#x3D;&gt; 详情列表 导入 : 列表三个手机都要点击进去详情页, 只需要一个组件,显示不同的数据即可 1234567891011121314151617181920212223242526272829303132# 入口&lt;router-link to=&quot;/detail/1&quot;&gt;手机1&lt;/router-link&gt;&lt;router-link to=&quot;/detail/2&quot;&gt;手机2&lt;/router-link&gt;&lt;router-link to=&quot;/detail/3&quot;&gt;手机3&lt;/router-link&gt;&lt;router-link to=&quot;/detail&quot;&gt;手机4&lt;/router-link&gt; 没有参数如何????# 规则routes: [ // 2 . 路由规则 &#123; path: &#x27;/detail/:id?&#x27;, component: Detail &#125;]# 获取参数的三种方式const Detail = &#123; template: ` // 方式1 : 组件中直接读取 &lt;div&gt; 显示详情页内容....&#123;&#123; $route.params.id &#125;&#125; &lt;/div&gt; `, created() &#123; // 方式2 : js直接读取 // 打印只会打印一次,因为组件是复用的,每次进来钩子函数只会执行一次 console.log(this.$route.params.id) &#125;, // 方式3 : 监听路由的参数,为什么不需要深度监听,因为一个路径变化,就会对应一个对新的路由对象(地址变) watch: &#123; $route(to, from) &#123; console.log(to.params.id) &#125; &#125;&#125; 6.2 路由对象 - $route 一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息 一个哈希值路径 &#x3D;&#x3D;&gt; 一个路由对象 $route.path 类型: string 字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。 # 后面?前面的内容 $route.params 类型: Object 一个 key&#x2F;value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。 一个 key&#x2F;value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。 $route.query 类型: Object 参数对象 一个 key&#x2F;value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 $route.hash 类型: string 当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。 $route.fullPath 类型: string 全路径 完成解析后的 URL，包含查询参数和 hash 的完整路径。 123456789# 演示 : &lt;router-link to=&quot;/detail/4?age=21#one&quot;&gt;detail&lt;/router-link&gt;&#123; path: &#x27;/detail/:id?&#x27;, component: detail &#125; 在组件内 created打印 this.$route&gt; fullPath: &quot;/detail/4?id=001#one&quot;&gt; hash : &quot;#one&quot;&gt; params : &#123;id:&#x27;4&#x27;&#125;&gt; query : &#123;age : 21&#125;&gt; path : &#x27;/detail/4&#x27; 6.3 嵌套路由 &#x3D;&gt; children 导入 : url测试 parent 和child, 想让child 在 parent 中显示 parent 的内部 添加 : &lt;router-view&gt; &lt;/router-view&gt; 规则里添加 children &#x2F;child 和 child 的区别 如果是/child &#x3D;&gt; 那么访问就可以直接访问#/child就可以访问 子组件 如果是child &#x3D;&gt; 那么访问就应该访问#/parent/child才可以访问子组件 123456789101112131415161718const parent = &#123; template: `&lt;p&gt;parent &lt;router-view&gt; &lt;/router-view&gt; &lt;/p&gt;`&#125;const child = &#123; template: `&lt;p&gt;child&lt;/p&gt;`&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/parent&#x27;, component: parent, children: [ &#123; path: &#x27;/child&#x27;, component: child &#125; ] &#125; ]&#125;) 6.4 命名路由 有时候，通过一个名称来标识一个路由显得更方便一些， 特别是在链接一个路由，或者是执行一些跳转的时候。 &#x3D;&#x3D;&#x3D;&gt; 场景 你可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。 &#x3D;&#x3D;&gt; 如何命名 1234567891011121314151617181920212223# 命名routes: [ &#123; path: &#x27;/parent&#x27;, name: &#x27;parent&#x27;, component: parent &#125;]# 入口链接 + 跳转 (使用 path 和 name 的转换)&lt;!-- 方式1 : url手动写 --&gt;&lt;!-- 方式2 : 入口链接 声明式导航 --&gt;&lt;router-link to=&quot;/parent&quot;&gt;点击&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; name : &#x27;parent&#x27; &#125;&quot;&gt;点击&lt;/router-link&gt; # 忘了 带 : 原始对象类型&lt;!-- 方式3 : 编程式导航 --&gt; fn() &#123; // this.$router.push(&#x27;/parent&#x27;) this.$router.push(&#123; name: &#x27;parent&#x27; &#125;) &#125; 6.5 命名视图 导入 : 有时候想同时 (同级) 展示多个视图， 需求 : 访问 &#x2F; 根目录 同时展示以下三个组件 三个组件 123456789const header = &#123; template: `&lt;p&gt;header &lt;/p&gt;`&#125;const main = &#123; template: `&lt;p&gt;main &lt;/p&gt;`&#125;const footer = &#123; template: `&lt;p&gt;footer &lt;/p&gt;`&#125; 规则 12345678910111213# 以前的那个方式只能显示三个 header# 演示之前的效果 routes: [ &#123; path: &#x27;/&#x27;, components: &#123; default: header, m: main, f: footer &#125; &#125;] 出口 123&lt;router-view&gt; &lt;/router-view&gt;&lt;router-view name=&quot;m&quot;&gt; &lt;/router-view&gt;&lt;router-view name=&quot;f&quot;&gt; &lt;/router-view&gt; 6.6 重定向12345678redirect: &#x27;/header&#x27;redirect: &#123; name: &#x27;header&#x27; &#125;redirect: to =&gt; &#123; // console.log(to) return &#123; name: &#x27;about&#x27; &#125;&#125; 6.7 组件传参 原始方式使用 $route获取 12345678910111213# 入口 &lt;router-link to=&quot;/header/3&quot;&gt;123&lt;/router-link&gt;# 规则routes: [ &#123; path: &#x27;/header/:id&#x27;, component: header, &#125;]# 获取参数const header = &#123; template: `&lt;p&gt;header &#123;&#123; $route.params.id &#125;&#125; &lt;/p&gt;`&#125; 布尔模式 12345678910111213141516171819# 入口 &lt;router-link to=&quot;/header/3&quot;&gt;123&lt;/router-link&gt;# 规则routes: [ &#123; path: &#x27;/header/:id&#x27;, component: header, // 如果 props 被设置为 true，route.params 将会被设置为组件属性 props: true &#125;]# 获取参数const header = &#123; // 参数 id 当成参数 props: [&#x27;id&#x27;], template: `&lt;p&gt;header &#123;&#123; id &#125;&#125; &lt;/p&gt;`&#125; 对象模式 12345678910111213141516# 入口 &lt;router-link to=&quot;/header&quot;&gt;123&lt;/router-link&gt;# 规则 routes: [ &#123; path: &#x27;/header&#x27;, component: header, props: &#123; foo: &#x27;0000&#x27; &#125; &#125; ]# 组件 const header = &#123; props: [&#x27;foo&#x27;], template: `&lt;p&gt;header &#123;&#123; foo &#125;&#125; &lt;/p&gt;` &#125; 函数模式 12345# 同对象模式一样# 区别是props值不一样 props: to =&gt; &#123; return &#123; foo: &#x27;0000&#x27; &#125; &#125; 注意 : 对象模式和函数模式参数 在props里,所以声明式导航那里就不要传参了 7.路由进阶7.1 元信息 规则声明 123456789routes: [ &#123; path: &#x27;/header&#x27;, component: header, meta: &#123; title: &#x27;XXXX&#x27; &#125; &#125;] 获取 123created() &#123; document.title = this.$route.meta.title&#125; 作用 : &#96;&#96;&#96;在路由导航的时候,可以用作判断 12345678910111213141516171819202122232425262728##### 7.2 编程式导航```jsconst one = &#123; template: ` &lt;div&gt; &lt;button @click=&quot;handleClick(&#x27;back&#x27;)&quot;&gt;返回 上一页&lt;/button&gt;&lt;button @click=&quot;handleClick(&#x27;push&#x27;)&quot;&gt;跳转 two页&lt;/button&gt;&lt;button @click=&quot;handleClick(&#x27;replace&#x27;)&quot;&gt;替换 two页&lt;/button&gt; &lt;/div&gt;`, methods: &#123; handleClick(type) &#123; if (type == &#x27;back&#x27;) &#123; // 返回 this.$router.back() &#125; else if (type == &#x27;push&#x27;) &#123; // 跳转 有历史记录 this.$router.push(&#x27;/two&#x27;) &#125; else &#123; // 替换 没有历史记录 this.$router.replace(&#x27;/two&#x27;) &#125; &#125; &#125;&#125;const two = &#123; template: `&lt;p&gt;two &lt;/p&gt;`&#125; 7.3 编程守卫12345678910111213router.beforeEach((to, from, next) =&gt; &#123; // 访问 login if (to.name == &#x27;login&#x27;) &#123; // 下一步 next() &#125; else &#123; // 停止跳转 next(false) // 跳转到下一步 next(&#123; name: &#x27;login&#x27; &#125;) 或者 使用路径 next(&#x27;/login&#x27;) &#125;&#125;) 第五部分 (Webpack)1.Webpack介绍1.1 什么是Webpack？ 前端模块化打包(构建)工具 WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块、其它的一些浏览器不能直接运行的拓展语言（Scss，less等）以及新语法，并将其转换和打包为合适的格式供浏览器使用。 1.2 为什么要使用Webpack? 浏览器不识别 SASS、Less &#x3D;&#x3D;&gt; 需要对Less&#x2F;ScSS 预编译CSS &#x3D;&gt; 供浏览器使用 项目中的模块化以及互相之间引用依赖包造成文件分散 &#x3D;&#x3D;&gt; 需要把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数 打包成了大文件,体积就变大了 &#x3D;&#x3D;&gt; 代码压缩 部分ES6语法有兼容问题 &#x3D;&gt; ES5 &#x3D;&gt; 浏览器使用 ……… 以上这些操作以前都是需要我们手动处理,这是非常繁琐的, 这个时候webpack就可以上场了,以上的这些操作 在webpack里,只要配置好,一下就可以都搞定了 1.3 webpack的基本功能 处理依赖：方便引用第三方模块，让模块更容易复用、避免全局注入导致的冲突、避免重复加载或者加载不必要的模块 合并代码：把各个分散的模块集中打包成大文件，减少HTTP的链接的请求次数，优化代码的体积(压缩代码) 各种插件：babel 把 ES6+ 转化为 ES5- 等 1.4 webpack的工作原理 简单的说就是分析代码，找到“require”、“import”、“define”等关键词，并替换成对应模块的引用。 在一个配置文件中，指明对某些文件进行编译、压缩、组合等任务。把你的项目当成一个整体，通过一个给定的主文件 （index.js），webpack将从这个文件开始找到你的项目的所有的依赖文件，使用loaders处理他们，最后打包为一个浏览器可 以识别的js文件。 1.5 webpack四个核心概念 入口(entry)、出口(output)、加载器(loader)、插件(plugins) 入口 : 要打包哪个文件 出口 : 要打包到哪里 加载器 : 加载除了js文件其他文件的功能 插件 : 处理加载器完成不了的功能, 使用插件 1.6 学习 手动配置 webpack 的目的 为了我们后面使用脚手架做准备, 能够完成webpack的基本安装 能够了解webpack配置文件的作用 能够说出webpack中loader 的作用 能够使用webpack处理常见的资源(css&#x2F;less&#x2F;图片) 能够说出webpack-dev-server的作用以及配置 2.Webpack入门案例和优化步骤2.1 node.js初始化项目 初始化一个nodejs的项目，命令npm init -y 为什么要使用npm init初始化项目 在node开发中使用npm init会生成一个pakeage.json文件，这个文件主要是用来记录这个项目的详细信息的，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。方便在以后的版本迭代和项目移植的时候会更加的方便。也是防止在后期的项目维护中误删除了一个包导致的项目不能够正常运行。使用npm init初始化项目还有一个好处就是在进行项目传递的时候不需要将项目依赖包一起发送给对方，对方在接受到你的项目之后再执行npm install就可以将项目依赖全部下载到项目里。话不多说我们就直接开始进行操作。 相当于idea帮我们初始化一个maven工程一样，如果使用webstorm的话，也可以直接创建node.js项目 2.2 Webpack第1阶段2.2.1 命名初始化阶段 项目名不能有汉字,不能取名叫 webpack 在Webstorm中创建空项目webpack-code，在Terminal中输入命令 : npm init -y，并生成 package.json, 安装 : npm i -D webpack webpack-cli 123webpack : 是 webpack 工具的核心包(但是不能用来当工具使用，所以还需要安装webpack-cli)webpack-cli : 提供了一些在终端中使用的命令-D(--save-dev) : 表示项目开发期间的依赖,也就是 : 线上代码中用不到这些包了 创建一个main.js文件 1console.log(&#x27;我就要被打包了,哦也&#x27;); 在 package.json的scripts中,添加脚本 12345 &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack ./main.js&quot; &#125;,// webpack 是webpack-cli 中提供的命令, 用来实现打包的// ./main.js 入口文件,要打包哪个文件 运行 : npm run build 设置开发状态 : mode 1234567891011&quot;build&quot; : &quot;webpack ./main.js --mode development&quot;// WARNING in configuration// The &#x27;mode&#x27; option has not been set, webpack will fallback to &#x27;production&#x27; for this value.// 如果没有设置 mode 配置项, webpack 会默认提供 生产环境(production)// Set &#x27;mode&#x27; option to &#x27;development&#x27; or &#x27;production&#x27; to enable defaults for each environment.// 项目开发的两种环境 1. 开发环境 (development) : 开发过程就是开发环境 2. 生产环境 (production) : 线上环境, 也就是 : 项目做好了,发布上线 生产环境下, 打包生产的js文件都是压缩后的, 开发环境下代码一般是不压缩的 隔行变色案例 创建 src/index.html main.js 隔行案例 &#x3D;&gt; index.html 123456789101112&lt;ul&gt; &lt;li&gt;战斗机1号&lt;/li&gt; &lt;li&gt;战斗机2号&lt;/li&gt; &lt;li&gt;战斗机3号&lt;/li&gt; &lt;li&gt;战斗机4号&lt;/li&gt; &lt;li&gt;战斗机5号&lt;/li&gt; &lt;li&gt;战斗机6号&lt;/li&gt; &lt;li&gt;战斗机7号&lt;/li&gt; &lt;li&gt;战斗机8号&lt;/li&gt; &lt;li&gt;战斗机9号&lt;/li&gt; &lt;li&gt;战斗机10号&lt;/li&gt;&lt;/ul&gt; 安装 juqery : npm i jquery, 并且引入 jquery 暂时引入 main.js , 在 main.js 里写入 12$(&#x27;li:odd&#x27;).css(&#x27;background&#x27;,&#x27;yellow&#x27;)$(&#x27;li:even&#x27;).css(&#x27;background&#x27;,&#x27;green&#x27;) 在index.html中引入jquery.js、main.js 修改index.html 将jquery.js的引入放到main.js中去，使用es6的语法（注意js引入js和html引入js不一样） 12345678//使用ES5的模块语法//const $ = require(&#x27;jquery&#x27;)// 使用ES6的模块化语法import $ from &#x27;jquery&#x27; // 优点 不用沿着路径去找$(&#x27;li:odd&#x27;).css(&#x27;background&#x27;,&#x27;yellow&#x27;)$(&#x27;li:even&#x27;).css(&#x27;background&#x27;,&#x27;green&#x27;) 运行：浏览器语法报错 问题 : 引入 main.js 会报错,因为浏览器不支持这个import 的Es6语法npm run build 之后，再将index.html中的main.js换成打包后的dist/main.js 后会ok,因为webpack 帮我们转化为浏览器能够识别的es5语法了 历程 : 123//1. 如果index.html 中引入 jquery , 再引入 mian.js (没有引入jquery了) =&gt; ok//2. 如果index.html 中没有引入 jquery , 直接使用es6的模块化语法 import , 引入main.js就会报错//3. 如果index.html 中没有引入 jquery , 直接使用es6的模块化语法 import , webapck打包出 dist/main.js 引入 dist/main.js ==&gt; ok 为什么 dist文件下的main.js 文件里的代码突然这么多 看图 (打包流程) code 记得保存一份 2.3 Webpack第2阶段Webpack配置方式 准备工作 : src源文件 : index.html和main.js webpack 打包有两种方式 命令行 配置文件 方式1：命令行 一般格式：”build” : 入口 –output-filename 出口 —-mode xxx(development&#x2F;product) 1234567* &quot;build&quot; : &quot;webpack ./mian.js&quot; --mode development* npm run build* 一般情况下 : 改为* &quot;build&quot; : 入口 --output 出口* &quot;build&quot;: &quot;webpack ./src/js/main.js --output-filename ./dist/app.js --mode development&quot;,** 验证 : index.html 引入 ./dist/app.js ​ 优势：写起来方便，想加什么就添加什么 ​ 劣势：一旦配置越来越多，就显的很臃肿了 方式 2 : 配置文件 步骤： 修改 package.json 中的 scripts , 脚本命令为： “build”: “webpack” 说明：当npm run build的时候，会自动寻找webpack的配置文件 项目根目录下, 创建一个 webpack.config.js文件 (文件名固定死) 说明：也可以专门指定其他文件 : –config webpack.XX.js 在 webpack.config.js 中,进行配置 12345678910111213141516/*该文件绝对不能使用类似import的es6语法，一定要保证它能通过浏览器的检查*///path:规范文件路径const path = require(&#x27;path&#x27;)module.exports = &#123; // 入口 entry: path.join(__dirname, &#x27;./src/main.js&#x27;), // 出口 output: &#123; // 出口目录 path: path.join(__dirname, &#x27;./dist&#x27;), filename: &#x27;app.js&#x27; &#125;, // 开发模式 mode: &#x27;development&#x27;&#125; 说明： webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置 不要在这个文件中使用ES6的的模块化 import语法 main.js里可以使用,是因为要通过webpack转化为es5的而这个是webpack 的配置文件,,它是要转化别人的,所以必须要通过 执行命令 : npm run build webpack 配置文件 html-webpack-plugin思考：当我们main.js打完包之后依然要手动引入到index.html中，有没有办法当我们打包完之后重新生成一个新的index.html并且把打完包之后的app.js引入 html-webpack-plugin 必备的插件 123作用 : 1. 能够根据指定的模板文件 (index.html),自动生成一个新的 index.html,并且注入到dist文件夹下 2. 能够自动引入js文件 安装 : npm i html-webpack-plugin 配置 : 12345678910111213141516171819202122232425第一步: 引入模块const htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)第二步: 配置module.exports =&#123; //入口 entry:path.join(_dirname,&#x27;./src/main.js&#x27;), //出口 output:&#123; //出口目录 path:path.join(__dirname,&#x27;./dist&#x27;), //出口文件 filename:&#x27;app.js&#x27; &#125;, //模式 mode:&#x27;development&#x27;, //插件plugins plugins:[ //配置html-webpack-plugin插件,使用插件 指定模板 new htmlWebpackPlugin(&#123; //指定模板文件 template:path.join(__dirname,&#x27;./src/index.html&#x27;) &#125;) ] &#125; webpack 配置文件 : webpack-dev-server思考：现在有一个需求，就是当我们需要更改隔行变色的颜色时候（注意：只能改src下的main.js而非dist目录下的app.js），我们每一次都需要手动重新打包，而在实际开发中这是极其损耗开发效率的，有没有办法在开发中我们直接修改颜色就能显示出效果呢？ webpack-dev-server 使用 webpack 必备的功能(插件) 作用 : 为使用 webpack 打包提供一个服务器环境（因为最终打包后的文件肯定是要运行在前端的服务器中） 1.1 自动为我们的项目创建一个服务器 1.2 自动打开浏览器 1.3 自动监视文件变化,自动刷新浏览器… 使用步骤 : 2.1 安装 : npm i -D webpack-dev-server 2.2 两种使用方式: 1-命令行 2-配置文件(推荐) 方式 1 : 命令行配置 脚本 : &quot;dev&quot; : &quot;webpack-dev-server&quot; 运行到 npm run dev 查看路径 : “http://localhost:8080/&quot; ｢wds｣: Project is running at http://localhost:8080/ 问题 1 : 自动打开? 解决 : 添加 --open 问题 2 : 指定端口号 解决 : 添加 --port 3001 问题 3 : 热更新 解决 : --hot ( 整个页面和整个项目打包 ) 123演示: 在浏览器调试样式的地方去掉ul的样式 /* background: skyblue; */然后分别看 加 --hot 和 不加 --hot 的区别重新运行脚本 方式 2 : 配置文件配置 12// hot 不要写在配置文件里面,,不然的话还要配其他插件麻烦&quot;dev&quot; : &quot;webpack-dev-server --hot&quot;, 1234devServer : &#123; open : true, port : 3001&#125; 2.4 Webpack第3阶段 打包上线 开发模式 : npm run dev &#x3D;&#x3D;&gt; 不会打包的 ,只会把项目放到服务器里 假设项目开发完成了,要上线,怎么操作? 1232.1 执行 : `npm run build` 对项目进行打包,生成dist文件2.2 模拟本地服务器 : 安装 : `npm i -g http-server`2.3 把dist文件里的内容放到服务器里即可, 直接运行`http-server` 2.5 Webpack 第4阶段 : 打包非js文件 webpack 只能处理 js 文件,非 js(css.less.图片.字体等)处理处理不了, 借助 loader 加载器 处理 css 文件 在src下创建一个css目录，目录下创建一个 index.css 文件, 然后在 main.js中引入 import &#39;../css/index.css&#39;;（不要在index.html中引入，让其干干净净） ul { ​ list-style:none; } 没有效果，因为css文件Webpack处理不了，它只能处理js 安装 : npm i -D style-loader css-loader 在 webpack.config.js 中,添加个新的配置项 module 在 module 中添加 loader 来处理 css 12345678910// loadermodule: &#123; rules: [ //1.处理 css // 注意点 use执行loader 顺序 从右往左 // css-loader : 读取css文件内容,将其转化为一个模块 // style-loader :拿到模块, 创建一个style标签,插入页面中 &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125; ]&#125; 6.运行npm run dev 处理 less 文件 创建一个 less 文件, 然后再 main.js 中 引入 import &#39;../css/index.less&#39;; 安装 : npm i -D less-loader less style-loader css-loader 在 webpack.config.js 中, 配置 module-&gt;rules 在 module 中, 添加 loader 来处理 less 12345678ul &#123; background-color: aqua; li &#123; &amp;:hover &#123; color: yellow; &#125; &#125;&#125; 配置 : 1&#123; test :/\\.less$/, use : [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;] &#125;, 处理 图片 文件 设置背景图片 .cls { width: 300px; height: 300px; background: url(‘..&#x2F;css&#x2F;4.jpg’); background-size: 100%; } 安装 : npm i -D url-loader file-loader url-loader (推荐) 和 file-loader 二选一即可 在 webpack.config.js 添加 loader 规则 12// 处理图片 &#123; test : /\\.(jpg|png)$/, use : [&#x27;url-loader&#x27;] &#125;, url-loader 默认会将图片转化为 base64 编码格式, 目的:提高性能 file-loader 在车里图片时, 会对文件进行重命名 : 12原始： background-image: url(../images/1.jpg);处理后： background-image: url(9c9690b56876ea9b4d092c0baef31bb3.jpg); base64 编码格式的图片说明 : 精灵图 : 将一些小图片合并为一张图片,减少请求次数,提高性能 字体图标 :直接将一些小的图片,合并到字体文件中,并且不会失真 base64 : 是一种编码格式,能够将图片、文字等常见的文件,转化为 base64 格式,这种字符串格式, 浏览器能够识别并且读取显示到页面中; base64 是一个字符串,也可以直接被内嵌到页面中, 或者 css 中 注意 : 大图片不适合用 base64 处理, 只有小的图标才适合 base64 处理 设置配置 1234567891011121314方式1 :&#123; test : /\\.(jpg|png)$/, use : [&#x27;url-loader?limit=57417&#x27;] &#125;, 方式2 : &#123; test: /\\.(jpg|png)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; // 比57417这个小 =&gt; 转化为base64 // 大于等于这个57417值 =&gt; 不会转base64 内部调用 file-loader 加载图片 limit: 57417 &#125; &#125; ] &#125;, 处理 字体 文件 准备字体图标: 字体图标文件 iconfont 或者 从阿里矢量图标里下载 拷贝到项目中的 css 文件夹中 在 main.js 中引入 css 文件 1import &#x27;../css/iconfont/iconfont.css&#x27; 使用 : 在 webpack.config.js 中配置 12// 4. 处理字体图标 &#123; test:/\\.(svg|woff|woff2|ttf|eot)$/,use:&#x27;url-loader&#x27;&#125; 处理 ES6 语法 现在的项目都是使用 ES6 开发的, 但是这些新的 ES6 语法, 并不是所有的浏览器都支持, 所以就需要有一个工具,帮我们转成 es5 语法, 这个就是: babel babel Babel is a JavaScript compiler. &#x3D;&#x3D;&gt; babel 是一个 JavaScript 编译器 webpack 只能处理 import &#x2F; export 这个 es6 模块化语法而其他的 js 新语法,应该使用 babel 来处理 比如 : var o = &#123; ...obj &#125; 在谷歌上可以,edge 就不可以 babel 的使用 : 6.1 安装 1 : npm i -D babel-core babel-loader@7 babel-core 是 babel 的核心包 babel-loader 加载 js 文件, 并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js 6.2 安装 2 : npm i -D babel-preset-env babel-preset-stage-2 babel-preset-* 表示能够解析什么版本的 js 语法 babel-preset-env : 表示能够解析 es2015,es2016,es2017,es2018 这些标准的语法 babel-preset-stage-2 : 用来解析经过会遇到,但是还没有被采纳为标准的语法 比如 : ‘abc’.padStart(10, ‘6’) : 准备 10 位字符,有 abc,前面不够用 6 补充,是 es2017 的语法, babel-polyfill与babel-plugin-transform-runtime 也是做兼容处理的,以前都是用这个,兼容更早的 6.3 配置 : 在 webpack.config.js 中添加一个 loader 1&#123; test: /\\.js$/, use: &#x27;babel-loader&#x27;, exclude: /node_modules/ &#125; 6.4 在项目根目录中创建 babel 的配置文件，叫：.babelrc 12345678910111213141516&#123;&quot;presets&quot;: [ &quot;env&quot;, &quot;stage-2&quot;],-----------// 暂时不用// 如果未来某一天真的用到了polify &quot;plugins&quot;: [ [&quot;transform-runtime&quot;, &#123; &quot;helpers&quot;: false, &quot;polyfill&quot;: true, &quot;regenerator&quot;: true, &quot;moduleName&quot;: &quot;babel-runtime&quot; &#125;] 6.5 测试 : 谷歌 和 edge 1234567var obj = &#123; name: &#x27;zs&#x27;, age: 20&#125;var o = &#123; ...obj &#125;console.log(o) webpack中文链接 : https://www.webpackjs.com/loaders/url-l 第六部分 (vue脚手架)1 vue是单文件组件 导 : 之前注册组件有什么缺点 ? 1- 缺乏语法高亮 2-格式不好整 3-没有专门的写css代码等等(非要写只能写行内样式) 参考 : vue &#x3D;&gt; 工具 &#x3D;&gt; 单文件组件 什么是单文件组件 ? 后缀为 .vue 的文件 单文件组件的三个组成部分 template (模板结构) script 组件的代码逻辑 style 样式 注意点 : 由于单组件最终要被引入，所以组件的配置项需要使用es6的导出语法export default&#123;...&#125; 单文件组件,无法直接在浏览器中使用,必须经过webpack 这种打包工具,处理后,才能在浏览器中使用 2 脚手架介绍 vue-cli 是 vue 的脚手架工具 作用 : vue-cli 提供了一条命令, 我们直接通过这条命令就可以快速的生成一个 vue 项目 (vue init XX) 。项目的基本结构、以及webpack配置项 全部配置 好了 为什么会有脚手架工具 ??? 因为webpack配置繁琐, 阻止一批想用vue但是不会 webpack 的开发人员,所以作者直接将所有 vue 项目中用到的配置全部帮你写好了,这样,就不需要开发人员再去配置基础 webpack 配置项了 也就是说,使用vue-cli这个脚手架工具后,再也不用担心 webpack 配置问题了, 我们前端只需要写 vue 代码, 来实现功能即可 3 脚手架工具使用 安装 : npm i -g vue-cli 查看脚手架版本：npm -v 安装完脚手架之后vue就可以当作命令工具来使用 初始化 vue 项目 : vue init webpack 项目名称 比如 : 在一个空文件夹中打开CMD命令窗口，使用命令vue init webpack vue-demo，其实就是脚手架在初始化项目 项目安装过程 : 12345678910? Project name # 回车? Project description # 回车? Author # 回车? Vue build standalone # =&gt; 运行时+编译 =&gt; 详见下面的问题1 ? Install vue-router? # Yes? Use ESLint to lint your code? # Yes =&gt; 详见下面的问题2? Pick an ESLint preset Standard # standard? Set up unit tests # No? Setup e2e tests with Nightwatch? # No? Should we run `npm install` for you after the project has been created? # (recommended) npm 如何开始 直接使用WebStorm打开项目即可 package.json配置说明&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, --inline 意思是信息显示在哪里 -progress 进度条 --config 指定哪个文件作为webpack的配置文件 4 文件项目介绍 详细介绍： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# build - webpack 相关配置- build.js - 生产环境构建代码- check-version.js 检查 node、npm 等版本- util.js 构建工具相关- vue-loader.config.js vue-loader 的配置文件- webpack.base.conf.js - webpack 的基础配置- webpack.dev.conf.js - webpack 开发环境配置- webpack.prod.conf.js - webpack 发布环境配置# config - vue 基本配置文件(比如:监听端口(17), 使用 eslint:(26))- dev.env.js - 开发环境变量- index.js 项目的一些配置 会帮助开发者配置大部分的一些设置，例如proxyTable: &#123;&#125;就是进行一些跨域设置。 好比脚手架帮我们配置了100个功能，可能我们只用了少数功能，当然，其中某些配置还需要我们开发者自行下载一些辅助插件方能生效- prod.env.js 生成环境变量# node_modules - node 安装的依赖包# src - 资源文件夹, 以后我们就在这个目录下写代码*************************重点************************************- assets - 静态资源要打包的文件 (图片 css 都放在这)- components - 公用组件- router - 路由- App.vue - 项目的根组件- main.js - 项目的入口文件(总逻辑)# static - 静态资源不要打包的文件 (图片 json 数据之类的)，例如打包之后的静态资源也可以放这- .gitkeep git 保持一个空文件能够上传到gitEE/gitHub/gitLab,因为 git 上传,会忽略空文件夹# .babelrc - babel 配置文件, (es6 语法编译配置,将 es6 转化为浏览器能够识别的代码)# .editorconfig - 编辑器配置（前端开发工具繁多，VsCode、WebStorm、HBuilder）- root = true- charset = utf-8 编码 utf8- indent_style = space 缩进 空格- indent_size = 2 缩进字符- end_of_line = lf 回车作为换行的标记- insert_final_newline = true 最近一空白行作为结尾- trim_trailing_whitespace = true 清除最结尾的空白- 设置如果生效使用 ? 需要配置插件使用，插件会自动检测到root = true，识别是编辑器的配置文件- 1. 安装 vscode 的 editorConfig for vscode（使用webstorm的同学自行百度）- 2. eslint 检测修复后# .eslintignore - eslint 检测忽略的地方- /build/- /config/- /dist/- /\\*.js 根目录下带.js 的# .eslintrc.js - eslint 的配置文件# .gitignore - git 的忽略文件# .postcssrc.js - css 配置文件 (啥也没有处理)# index.html - 页面入口# package.json - 项目配置文件 4.1 参考:standard standard 代码规范 4.2 参考：src assets 静态资源 components 组件 HelloWorld.vue vue提供的展示组件主页 route/index.js &#x3D;&gt; 路由 一定要记住 :Vue.use(Router) 模块化公工程中一定要安装路由插件 .js 就是一个模块 官网里 也提到 https://router.vuejs.org/zh/installation.html App.vue根组件 &#x3D;&gt; 指定路由出口 脚手架之后,所有的组件都将渲染到 app.vue 中 app中的 #app 还是index.html中的 #app, app.vue 中的会覆盖前者可以通过分别添加 title 属性验证一下 路由出口要写在 app.vue 组件模板中 main.js 入口 js 文件 作用 : 创建 vue 实例,导入其他组件并挂在到 vue 实例上 Vue.config.productionTip = false 不要打印提示 检测 no new : 见后面的检测警告 123456new Vue(&#123; el: &#x27;#app&#x27;, // 目标显示 router, // 挂载路由 components: &#123; App &#125;, // 注册组件 App template: &#x27;&lt;App/&gt;&#x27; // 模板显示组件 app&#125;) 5 问题处理5.1 - 问题1 : 两种编译模式 和 @ 参考 : vue.js &#x3D;&gt; 安装 &#x3D;&gt; 对不同构建本版本的解释 我们选择的是 Runtime + Compiler 模式 : ( 运行时 + 编辑器) 运行时模式 : 用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。 1234567891011// 需要编译器new Vue(&#123; template: &#x27;&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;&#x27;&#125;)// 不需要编译器new Vue(&#123; render (h) &#123; return h(&#x27;div&#x27;, this.hi) &#125;&#125;) 完整版版本选用 : ES Module (基于构建工具使用) : vue.esm.js build &#x3D;&gt; webpack.base.config.js &#x3D;&gt; 37 行 alias(别名) ‘vue$’: ‘vue&#x2F;dist&#x2F;vue.esm.js’, @ : 就是src的绝对路径 build &#x3D;&gt; webpack.base.config.js &#x3D;&gt; 38 行 alias(别名) ‘@’: resolve(‘src’), 123router/index.js =&gt; import HelloWorld from &#x27;@/components/HelloWorld&#x27; import HelloWorld from &#x27;C:/users/.../src/components/HelloWorld&#x27; 5.2 - 问题2 : ESLint 概念 : ESLint 是在 JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。 在 vscode等编辑工具 中, 可以提示语法错误 在许多方面，它和 JSLint、JSHint 相似，除了少数的例外： 如何使用eslint ? 1-安装vscode插件 ESlint 2-vscode设置里添加一些配置 1234567891011&quot;editor.formatOnSave&quot;: true, //#每次保存的时候自动格式化 &quot;eslint.autoFixOnSave&quot;: true, // #每次保存的时候将代码按eslint格式进行修复 &quot;eslint.validate&quot;: [ &#123; &quot;language&quot;: &quot;html&quot;, &quot;autoFix&quot;: true &#125;, &#123; &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true &#125;, &#123; &quot;language&quot;: &quot;javascript&quot;, &quot;autoFix&quot;: true &#125;, &#123; &quot;language&quot;: &quot;wpy&quot;, &quot;autoFix&quot;: true &#125; ], &quot;prettier.eslintIntegration&quot;: true, // #让prettier使用eslint的代码格式进行校验 &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, &quot;editor.formatOnType&quot;: true //#让函数(名)和后面的括号之间加个空格 关闭 Eslint : 参考 : config/index.js &#x3D;&#x3D;&gt; 26行 : dev.useEslint 设置为false 重启项目: npm run dev 5.3 问题3 : vscode安装 格式化插件 Prettier 安装 vscode 插件 Prettier -Code formatter 功能1 : shift + alt + F &#x3D;&gt; 格式化代码 功能2 : 配合 eslint : 见上一个问题的配置 5.4 问题4 : 检测警告1234eslint-disable-next-line # 忽略检测下一行 可以使用单行注释/多行注释,其他都是多行注释eslint-disable # 忽略当前整个文件 多行注释 /* */eslint-disable no-new # 忽略前面是new开头 记录到这里 方便自己以后复习回忆 兄弟们可以参考参考","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"SSM总结","slug":"SSM","date":"2022-10-10T01:56:25.000Z","updated":"2022-10-10T06:14:33.704Z","comments":true,"path":"2022/10/10/SSM/","link":"","permalink":"http://example.com/2022/10/10/SSM/","excerpt":"","text":"关于SSM的相关总结 准备通过这篇文章来总结一下SSM框架,也算是复习总结一下SSM框架就是 Spring + SpringMVC + MyBatis Spring1.Spring是什么？ 是一个轻量级的开源框架，是为解决企业应用开发的复杂性而创建的 是一个三层架构 Web层：Spring MVC； 业务层 ：Spring的IoC； 持久层 ：Spring的JDBC、ORM、等持久层框架； Spring的核心：控制反转(IoC)和面向切面编程(AOP)； IoC（Inverse of Control，控制反转）: 指的是将对象的创建权交给 Spring 去创建。 使用 Spring 之前， 对象的创建都是由我们使用 new 创建，而使用 Spring 之后，对象的 创建都交给了 Spring 框架。 AOP（Aspect Oriented Programming，面向切面编程）: AOP 用来封装多个类的公共行为，将那些与业务无关， 却为业务模块所共同调用的逻辑封装起来，减少系统的重复 代码，降低模块间的耦合度。另外，AOP还解决一些系统层 面上的问题，比如日志、事务、权限等。 2.Spring是干什么的？ 方便解耦，简化开发； 方便的对程序进行拦截、运行、监控等功能； 可以对事务声明； 属于一个万能的框架，方便集成各种优秀框架； 降低 Java EE API 的使用难度 （Spring 对 Java EE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些 API 应用的难度大大降低） 方便程序的测试 3.Spring怎么用？ 这里我就不概述了，具体怎么用可以去百度、查API SpringMVC1.SpringMVC是什么？ 可以将SpringMVC看成Spring的一个组件 Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。Spring MVC 角色划分清晰，分工明细，并且和 Spring 框架无缝结合。Spring MVC 是当今业界最主流的 Web 开发框架，以及最热门的开发技能。在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。 Spring MVC 框架采用松耦合可插拔的组件结构，具有高度可配置性，比起其它 MVC 框架更具有扩展性和灵活性。此外，Spring MVC 的注解驱动和对 REST 风格的支持，也是它最具特色的功能。无论是在框架设计，还是扩展性、灵活性等方面都全面超越了 Struts2 等 MVC 框架。并且由于 Spring MVC 本身就是 Spring 框架的一部分，所以可以说与 Spring 框架是无缝集成，性能方面具有先天的优越性，对于开发者来说，开发效率也高于其它的 Web 框架，在企业中的应用越来越广泛，成为主流的 MVC 框架。 SpringMVC的优点 清晰地角色划分，Spring MVC在Model、View和Controller方面提供了一个非常清晰的角色划分，这3个方面真正是各司其职，各负其责。 灵活的配置功能，可以把类当作 Bean 通过 XML 进行配置。 提供了大量的控制器接口和实现类，开发者可以使用 Spring 提供的控制器实现类，也可以自己实现控制器接口。 真正做到与 View 层的实现无关。它不会强制开发者使用 JSP，可以根据项目需求使用 Velocity、FreeMarker 等技术。 国际化支持 面向接口编程 与 Spring 框架无缝集成 流程图 MyBatis1.MyBatis是什么？ MyBatis是一款优秀的持久层框架 它支持定制化SQL、存储过程以及高级映射。 Mybatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。 Mybatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO(Plain Old Java Object普通老式Java对象)为数据库中的记录。 小小的扩展几个点持久化持久化是将程序数据在持久状态和瞬时状态间转换的机制 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保 存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 持久层 完成持久化工作的代码块 . ——&gt; dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】 2.为什么需要MyBatis？ Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . 传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) —&gt;对象关系映射 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别 MyBatis的优点 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。 简单了解后我们就大概了解了什么是SSM SSM 框架业务执行流程图 SSM程序流程 1.整个SSM框架使用maven依赖管理和构建，将其打包成war包，部署到服务器将其运行。使用spring boot框架也可以打包成jar包部署。 2.SSM项目一般分为前端和后端两个部分，前端页面UI界面用bootstrap和jsp或者现在流行的vue等技术实现，后台则由SSM框架来搭建和编写，前后端交互部分则由ajax俩发送请求来处理。 3.springMVC控制器，用于页面的跳转请求和对具体的视图解析，而处理不了的请求则交给tomcat服务器来处理。 4.编写对应的Mappper接口以及Mapper文件，将其扫描进spring的ioc容器中，再由mybatis将对数据库的增删改查。 5.在spring容器中，有三层架构–&gt;Controller，Service，Dao层，分别处理不同的事务逻辑 6.有前端发送ajax请求给springMVC，后springMVC将其数据解析成json数据返回给前端页面，在前端用js解析成json在前端显示。 7.增删改查操作都是有ajax请求来处理。 8.具体的流程图由下图所示： spring将各层进行整合 通过spring管理持久层的mapper（dao接口） 通过spring管理业务层service，service中可以调用mapper接口 spring进行事物管理 通过spring管理表现层Handle，Handle中可以调用service接口。 mapper、service、Handle都是javabean 以上就是编程小白关于SSM的总结了 不过是参考百度、csdn大佬的文章,大家参考参考就好了~","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"20岁","slug":"20岁","date":"2022-10-08T08:23:39.000Z","updated":"2022-10-09T13:16:34.076Z","comments":true,"path":"2022/10/08/20岁/","link":"","permalink":"http://example.com/2022/10/08/20%E5%B2%81/","excerpt":"","text":"关于生日今天十月八号了，前几天放国庆在家休息了几天、顺便过了自己的二十岁生日，口罩的原因，只是喊上几个亲朋好友在家吃了顿饭，想想也有点感慨，自己怎么就二十岁了,都说十八岁后人生就像按了加速键,好像也确实如此.明年这个时候我也应该在公司上班了.还是希望自己能更加自律吧，自己约束自己, 加油. &gt; 跑步是个好习惯，继续坚持 &gt; 健身也不能少，坚持 &gt; 身体是革命的本钱","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"如何搭建博客","slug":"我的第一篇博客文章","date":"2022-09-06T15:35:57.000Z","updated":"2022-10-10T07:17:10.264Z","comments":true,"path":"2022/09/06/我的第一篇博客文章/","link":"","permalink":"http://example.com/2022/09/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"如何搭建博客? 具体如何搭建博客我就不啰嗦了参考视频：视频链接 搭建完后可以下载不同的博客主题我个人使用的是 yilia和butterfly 大家可以任选其一，当然也可以去查找不一样的主题 推荐文档教程： butterfly主题链接 详细教程文档可以百度，教程也比较详细","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"}]}],"categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}